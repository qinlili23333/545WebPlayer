<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - loaders - MMD loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: transparent;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>

    <script src="https://unpkg.com/three@0.145.0/examples/js/libs/ammo.wasm.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.145.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/"
				}
			}
		</script>

    <script type="module">

        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { MMDAnimationHelper } from 'three/addons/animation/MMDAnimationHelper.js';

        let stats;

        let mesh, camera, scene, renderer, effect;
        let helper, ikHelper, physicsHelper;

        const clock = new THREE.Clock();

        Ammo().then(function (AmmoLib) {

            Ammo = AmmoLib;

            init();
            animate();

        });


        function init() {

            const container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 30;

            // scene

            scene = new THREE.Scene();
            //scene.background = new THREE.Color(0xbec23f);

            //const gridHelper = new THREE.PolarGridHelper(30, 0);
            //gridHelper.position.y = - 10;
            //scene.add(gridHelper);

            const ambient = new THREE.AmbientLight(0x666666);
            scene.add(ambient);

            const directionalLight = new THREE.DirectionalLight(0x887766);
            directionalLight.position.set(- 1, 1, 1).normalize();
            scene.add(directionalLight);

            //

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            effect = new OutlineEffect(renderer);

            // STATS

            stats = new Stats();
            container.appendChild(stats.dom);

            // model

            function onProgress(xhr) {

                if (xhr.lengthComputable) {

                    const percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '% downloaded');

                }

            }


            const modelFile = './%E7%AC%99%E6%AD%8Cv2_1004/%E7%AC%99%E6%AD%8Cv2_1004.Pmx';
            const vmdFiles = ['./qz/千盏动作数据.vmd'];

            helper = new MMDAnimationHelper({
                afterglow: 2.0
            });
            window.bodymesh, window.fanmesh = false;
            const checkBind = () => {
                if (window.bodymesh && window.fanmesh) {
                    bodymesh.skeleton.bones[71].add(fanmesh);
                }
            };
            const loader = new MMDLoader();

            loader.loadWithAnimation(modelFile, vmdFiles, function (mmd) {

                mesh = mmd.mesh;
                mesh.position.y = -10;
                scene.add(mesh);
                window.bodymesh = mesh;
                console.log(mesh);

                helper.add(mesh, {
                    animation: mmd.animation,
                    physics: true
                });

                ikHelper = helper.objects.get(mesh).ikSolver.createHelper();
                ikHelper.visible = false;
                scene.add(ikHelper);

                physicsHelper = helper.objects.get(mesh).physics.createHelper();
                physicsHelper.visible = false;
                scene.add(physicsHelper);

                initGui();
                checkBind();
            }, onProgress, null);

            const fanloader = new MMDLoader();
            loader.loadWithAnimation("./qz/%E9%9B%B6%E5%BC%8F%E6%89%87%E5%AD%90%E6%94%B9/%E9%9B%B6%E5%BC%8F%E8%88%9E%E6%89%871.3_%E6%BC%86.pmx", "./qz/%E5%8D%83%E7%9B%8F%20%E6%89%87%E5%AD%90.vmd", function (mmd) {

                mesh = mmd.mesh;
                mesh.position.y = 0;
                window.fanmesh = mesh;
                console.log(mesh);
                helper.add(mesh, {
                    animation: mmd.animation,
                    physics: true
                });

                checkBind();
            }, onProgress, null);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 10;
            controls.maxDistance = 100;

            window.addEventListener('resize', onWindowResize);

            function initGui() {

                const api = {
                    'animation': true,
                    'ik': true,
                    'outline': true,
                    'physics': true,
                    'show IK bones': false,
                    'show rigid bodies': false
                };

                const gui = new GUI();

                gui.add(api, 'animation').onChange(function () {

                    helper.enable('animation', api['animation']);

                });

                gui.add(api, 'ik').onChange(function () {

                    helper.enable('ik', api['ik']);

                });

                gui.add(api, 'outline').onChange(function () {

                    effect.enabled = api['outline'];

                });

                gui.add(api, 'physics').onChange(function () {

                    helper.enable('physics', api['physics']);

                });

                gui.add(api, 'show IK bones').onChange(function () {

                    ikHelper.visible = api['show IK bones'];

                });

                gui.add(api, 'show rigid bodies').onChange(function () {

                    if (physicsHelper !== undefined) physicsHelper.visible = api['show rigid bodies'];

                });

            }

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            effect.setSize(window.innerWidth, window.innerHeight);

        }

        //

        function animate() {

            requestAnimationFrame(animate);

            stats.begin();
            render();
            stats.end();

        }

        function render() {

            helper.update(clock.getDelta());
            effect.render(scene, camera);

        }

    </script>

</body>

</html>